package om.tnavigator.uned;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.InetAddress;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import om.tnavigator.UserSession;
import om.tnavigator.auth.UncheckedUserDetails;

/**
 * Om test navigator; implementation of the test delivery engine.<br/><br/>
 * This is a special implementation to support several features needed to preview tests generated by 
 * GEPEQ authoring tool (see {@link om.tnavigator.uned.PreviewNavigatorServlet#handleCustom(boolean,
 * java.lang.String,om.tnavigator.NavigatorServlet.RequestTimings,javax.servlet.http.HttpServletRequest,
 * javax.servlet.http.HttpServletResponse) handleCustom(boolean bPost, String sPath, RequestTimings rt,
 * HttpServletRequest request, HttpServletResponse response)}).<br/><br/>
 * As it is derived from <i>LogoutNavigatorServlet</i> it also adds a <i>Logout</i> button within 
 * navigation bar of test pages when an user has been logged in.<br/><br/>
 * It also tries to check ellapsed time between user actions to invalidate user session if have passed 
 * a lot of time.<br/><br/>
 * Moreover it loads additional information from navigator configuration file:<br/><br/>
 * <ol>
 * <li>Supports encryption of some properties.</li>
 * <li>Provides information of a second DB used for login authentication.</li>
 * <li>Improved mail configuration.</li>
 * </ol>
 * <b>IMPORTANT</b>: For security reasons it is only recommended to use it in an environment for 
 * previewing tests generated with the GEPEQ authoring tool.
 */
@SuppressWarnings("serial")
public class PreviewNavigatorServlet extends LogoutNavigatorServlet
{
	/**
	 * Handler for customize UNED specific options/tasks for Test Navigator.<br/><br/>
	 * For now we have been implemented the following options:<br/><br/>
	 * <table border="1">
	 * <tr><th>Option</th><th>Description</th></tr>
	 * <tr><td>/!logout-result</td><td>Displays a page indicating that the user has logged out.</td></tr>
	 * <tr><td>/!stopallsessionsforquestion</td><td>Stops all opened sessions for a question.<br/><br/>
	 * Needed to be able to clear question's jar from cache of OpenMark Question Engine.</td></tr>
	 * <tr><td>/!preview</td><td>Clear authentication, fake oucu and accesibility cookies and redirects to
	 * rest of the URL.<br/><br/>
	 * Used to preview tests allways logged out and without accesibility options enabled</td></tr>
	 * <tr><td>/!logged-preview</td><td>Clear navigation session cookie and redirects to rest of URL.<br/><br/>
	 * Used to avoid restoring old state when previewing a test logged in as an OpenMark user.</td></tr>
	 * </table>
	 * @param bPost Flag indicating if servlet has been invoked by POST (true) or GET (false)
	 * @param sPath Path info
	 * @param rt Request timings
	 * @param request Servlet request
	 * @param response Servlet response
	 * @return true if a custom option has been handled (and we need to stop handling), false otherwise
	 */
	@Override
	protected boolean handleCustom(boolean bPost,String sPath,RequestTimings rt,HttpServletRequest request,
		HttpServletResponse response) throws Exception
	{
		boolean handled=false;
		if (sPath.startsWith("/!stopallsessionsforquestion/"))
		{
			handleStopAllSessionsForQuestion(
				sPath.substring("/!stopallsessionsforquestion/".length()),rt,request,response);
			handled=true;
		}
		else if (sPath.startsWith("/!preview/"))
		{
			String authCookie=getAuthCookie(request);
			if (authCookie!=null)
			{
				UncheckedUserDetails uncheckedUser=getUncheckedUser(authCookie);
				resetForUncheckedUser(uncheckedUser);
				clearAuthCookie(response);
			}
			clearFakeOucuCookie(response);
			clearAccessibilityCookie(response);
			String requestURL=request.getRequestURI();
			String contextPath=request.getContextPath();
			StringBuffer testPageURL=
				new StringBuffer(requestURL.substring(0,requestURL.indexOf(contextPath)));
			testPageURL.append(contextPath);
			testPageURL.append(sPath.substring("/!preview".length()));
			if (request.getQueryString()!=null)
			{
				testPageURL.append('?');
				testPageURL.append(request.getQueryString());
			}
			response.sendRedirect(testPageURL.toString());
			handled=true;
		}
		else if (sPath.startsWith("/!logged-preview/"))
		{
			String subPath=sPath.substring("/!logged-preview".length());
			Pattern pTestId=Pattern.compile("^/([^/]+)/?(.*)$");
			Matcher m=pTestId.matcher(subPath);
			if (m.matches())
			{
				String testID=m.group(1);
				clearNavigatorSessionCookie(response,testID);
			}
			String requestURL=request.getRequestURI();
			String contextPath=request.getContextPath();
			StringBuffer testPageURL=
				new StringBuffer(requestURL.substring(0,requestURL.indexOf(contextPath)));
			testPageURL.append(contextPath);
			testPageURL.append(subPath);
			if (request.getQueryString()!=null)
			{
				testPageURL.append('?');
				testPageURL.append(request.getQueryString());
			}
			response.sendRedirect(testPageURL.toString());
			handled=true;
		}
		else
		{
			handled=super.handleCustom(bPost,sPath,rt,request,response);
		}
		if (!handled && !sPath.startsWith("/!auth/"))
		{
			if (!touch(request,response))
			{
				String requestURL=request.getRequestURI();
				String contextPath=request.getContextPath();
				StringBuffer logoutPageURL=
					new StringBuffer(requestURL.substring(0,requestURL.indexOf(contextPath)));
				logoutPageURL.append(contextPath);
				logoutPageURL.append("/!auth/logout");
				response.sendRedirect(logoutPageURL.toString());
				handled=true;
			}
		}
		return handled;
	}
	
	/**
	 * Stop all sessions that are using a question.
	 * @param sQuestionId Question id (can be encrypted)
	 * @param rt Request timings
	 * @param request Servlet request
	 * @param response Servlet response
	 */
	protected void handleStopAllSessionsForQuestion(String sQuestionId,RequestTimings rt,
			HttpServletRequest request,HttpServletResponse response) throws Exception
	{
		// Decrypt question id if needed
		sQuestionId=((UnedNavigatorConfig)getNavigatorConfig()).decryptFromGEPEQ(sQuestionId);
		if (sQuestionId==null)
		{
			sendError(null,request,response,HttpServletResponse.SC_FORBIDDEN,false,false,null,"Forbidden",
				"You are not authorised to access this URL.",null);
		}
			
		// Check that access is allowed.
		if (!(getNavigatorConfig().isTrustedQE(InetAddress.getByName(request.getRemoteAddr())) || 
			checkSecureIP(request)))
		{
			sendError(null,request,response,HttpServletResponse.SC_FORBIDDEN,false,false,null,"Forbidden",
				"You are not authorised to access this URL.",null);
		}
		
		// Iterate user sessions
		for (UserSession us:getSessions().values())
		{
			if (us.getOmServiceSession()!=null)
			{
				// We close all sessions using the question
				String usQuestionId=us.getOmServiceSession().getQuestionID();
				if (usQuestionId!=null && usQuestionId.equals(sQuestionId))
				{
					stopQuestionSession(rt,us);
				}
			}
		}
	}
	
	/**
	 * Handles <i>?restart</i> option with tests.<br/><br/>
	 * This implementation does not perform checks and always try to restart test.<br/><br/>
	 * If test has not been already started then starts it.
	 * @param sTestID Test ID
	 * @param rt Request timings
	 * @param bPost Flag indicating if the request is POST (true) or GET (false)
	 * @param us User session
	 * @param request Servlet request
	 * @param response Servlet response
	 * @return true because <i>?restart</i> option always is handled
	 * @throws Exception
	 */
	@Override
	protected boolean handleRestartTest(String sTestID,RequestTimings rt,boolean bPost,UserSession us,
		HttpServletRequest request,HttpServletResponse response) throws Exception
	{
		if (us.getTestId()==null)
		{
			// Start this test
			handleStart(rt,sTestID,us,-1,request,response);
		}
		else
		{
			// Restart this test
			handleRestart(rt,us,request,response);
		}
		return true;
	}
	
	/**
	 * Check if we are logged into a test or if we use the <i>?restart</i> option for a test.
	 * @param us User session
	 * @param sCommand Command string
	 * @return true if we are logged into a test or if we use the <i>?restart</i> option for a test, 
	 * false otherwise
	 */
	@Override
	protected boolean checkTestLogged(UserSession us,String sCommand)
	{
		return us.getTestId()!=null || (!us.isSingle() && "?restart".equals(sCommand));
	}
	
	/**
	 * Clear fake OUCU cookie.
	 * @param response HTTP response
	 */
	protected void clearFakeOucuCookie(HttpServletResponse response)
	{
		// Clear fake OUCU cookie
		Cookie c=new Cookie(FAKEOUCUCOOKIENAME,"");
		c.setMaxAge(0);
		c.setPath("/");
		response.addCookie(c);
	}
	
	/**
	 * Clear accessibility cookie.
	 * @param response HTTP response
	 */
	protected void clearAccessibilityCookie(HttpServletResponse response)
	{
		// Clear accessibility cookie
		Cookie c=new Cookie(ACCESSCOOKIENAME,"");
		c.setMaxAge(0);
		c.setPath("/");
		response.addCookie(c);
	}
	
	/**
	 * Clear navigator session cookie for indicated test.
	 * @param response HTTP response
	 * @param testId Test identifier
	 */
	protected void clearNavigatorSessionCookie(HttpServletResponse response,String testId)
	{
		// Clear navigator session cookie for indicated test
		StringBuffer cookieName=new StringBuffer(COOKIENAME);
		cookieName.append('_');
		cookieName.append(testId);
		Cookie c=new Cookie(cookieName.toString(),"");
		c.setMaxAge(0);
		c.setPath("/");
		response.addCookie(c);
	}
	
	/**
	 * @param request HTTP request
	 * @return Authentication cookie from HTTP request
	 */
	@SuppressWarnings({"rawtypes","unchecked"})
	protected String getAuthCookie(HttpServletRequest request)
	{
		String authCookie=null;
		try
		{
			Class authClass=Class.forName(getNavigatorConfig().getAuthClass());
			Method cookieGetter=authClass.getMethod("getCookie",new Class[] {HttpServletRequest.class});
			if (Modifier.isStatic(cookieGetter.getModifiers()))
			{
				authCookie=(String)cookieGetter.invoke(null, new Object[] {request});
			}
		}
		catch (Exception e)
		{
			authCookie=null;
		}
		return authCookie;
	}
	
	/**
	 * @param authCookie Authentication cookie (string)
	 * @return Unchecked user from authentication cookie
	 */
	@SuppressWarnings({"rawtypes","unchecked"})
	protected UncheckedUserDetails getUncheckedUser(String authCookie)
	{
		UncheckedUserDetails uncheckedUser=null;
		String authSuffix=null;
		String authClassname=getNavigatorConfig().getAuthClass();
		if (authClassname.endsWith("Auth"))
		{
			authSuffix="Auth";
		}
		else if (authClassname.endsWith("Authentication"))
		{
			authSuffix="Authentication";
		}
		if (authSuffix!=null)
		{
			StringBuffer uncheckedUserClassname=new StringBuffer();
			uncheckedUserClassname.append(
				authClassname.substring(0,authClassname.length()-authSuffix.length()));
			uncheckedUserClassname.append("UncheckedUser");
			try
			{
				Class uncheckedUserClass=Class.forName(uncheckedUserClassname.toString());
				Constructor uncheckedUserConstructor=
					uncheckedUserClass.getConstructor(new Class[] {String.class});
				uncheckedUser=
					(UncheckedUserDetails)uncheckedUserConstructor.newInstance(new Object[] {authCookie});
			}
			catch (Exception e)
			{
				uncheckedUser=null;
			}
		}
		return uncheckedUser;
	}
	
	/**
	 * Reset authentication initializations for an specific user. 
	 * @param uncheckedUser Unchecked user
	 */
	@SuppressWarnings({"rawtypes","unchecked"})
	protected void resetForUncheckedUser(UncheckedUserDetails uncheckedUser)
	{
		if (uncheckedUser!=null)
		{
			try
			{
				Class authClass=Class.forName(getNavigatorConfig().getAuthClass());
				Method resetForUserMethod=authClass.getMethod("resetForUser",new Class[] {String.class});
				if (Modifier.isStatic(resetForUserMethod.getModifiers()))
				{
					resetForUserMethod.invoke(null,new Object[] {uncheckedUser.getUsername()});
				}
			}
			catch (Exception e)
			{
			}
		}
	}
	
	/**
	 * Clear authentication cookie.
	 * @param response HTTP response
	 */
	@SuppressWarnings({"rawtypes","unchecked"})
	protected void clearAuthCookie(HttpServletResponse response)
	{
		try
		{
			Class authClass=Class.forName(getNavigatorConfig().getAuthClass());
			Method clearCookieMethod=
				authClass.getMethod("clearCookie",new Class[] {HttpServletResponse.class});
			if (Modifier.isStatic(clearCookieMethod.getModifiers()))
			{
				clearCookieMethod.invoke(null,new Object[] {response});
			}
		}
		catch (Exception e)
		{
		}
	}
}
